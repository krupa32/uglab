
ABSTRACT DATA TYPES
-------------------

An abstract data type (ADT)is one that is defined ONLY by the operations 
that may be performed on it. Typically, an ADT exports ONLY a set of 
interfaces/methods/functions. The details of how those interfaces are
implemented are completely hidden to the user of the ADT.

For example, an abstract stack data type may be defined using the push and
pop operations. But a stack may be implemented using an array or linked list
or some other data structure. But that is irrelevant to the user of the stack
ADT. The same is true for a queue ADT also.

In general, an abstract data type is not instantiable. That is, the user does
not typically allocate memory or object of an ADT. Instead, the user always
allocates memory/object of a 'derived' or 'concrete' data type which 
'implements' the operations of the ADT. For example, a 'arraystack' is a
derived or concrete implementation of a stack ADT, and users typically
create only objects of type arraystack.



DEFINING ABSTRACT DATA TYPES
----------------------------

Since ADTs are defined only using the operations it exports, it is defined
by creating a header file which declares the prototypes of these operations.


GENERAL INSTRUCTIONS
--------------------

For this session, you will be defining an abstract stack data type with the
following operations. Create a file stack.h which declares the following
operations of the stack ADT.

    void * stack_create(int size);

    void stack_free(void *stack);

    int stack_push(void *stack, char c);

    int stack_pop(void *stack, char *c);

    int stack_empty(void *stack);

    int stack_full(void *stack);

The function 'stack_create' creates a character stack of 'size' characters and 
returns a pointer which can be used to reference that stack. The user can
create multiple stacks and uses this pointer to perform operations on the
corresponding stack. The return value of 'void *' ensures that the user of
the ADT does not know what data structure is used by the implementation.
You will get a better idea about the returned pointer once you read exercise 1.

The function 'stack_push' and 'stack_pop' are similar to the push and pop
you have implemented as part of 03-stack session. That is, stack_push will
push the character and return 1, or return 0 if stack is full. And stack_pop
should pop topmost character in stack and return 1, or return 0 if stack
is empty.

The functions 'stack_empty' and 'stack_full' return 1 depending on
whether the stack is empty or full. Otherwise it returns 0.


Exercise 1
----------

Create a file arraystack.h that declares the following structure.

    struct arraystack
    {
        char *arr;
        int size;
        int top;
    };

Create a file arraystack.c which includes "stack.h" and "arraystack.h".
The file should implement all stack ADT operations using the 'arraystack'
structure to represent the stack.

The function 'stack_create' should malloc a struct arraystack and return the
pointer. In addition, it should also malloc 'size' characters and assign to
'arr', and initialize top to 0.

The function 'stack_free' should free the memory allocated for 'arr', and
then free the memory allocated for the struct arraystack.

The functions 'stack_push' and 'stack_pop' can typecast the 'void *stack' to
'struct arraystack *' and implement the stack operations.

You can test using 'make test_arraystack'.


Exercise 2
----------

*** YOU HAVE TO FINISH EXERCISE 1 BEFORE PROCEEDING ***

Create a file compare.c with the following function.

    int stack_compare(void *stack1, void *stack2);

The function should compare the elements of both the stacks and return 1
if the elements are same, and return 0 otherwise. Also, when the function
returns, the contents of stack1 and stack2 should be intact.

Since the stack ADT does not reveal the implementation details of the stack,
the way to do this is as follows. Create a new stack called tmp. Pop one
element from stack1 and stack2 repeatedly. If the elements are different,
then restore stack1 and stack2, and return 0. If the elements are same,
then push the character to tmp stack and continue the loop.

By the nature of the algorithm, tmp stack contains characters that are common
in both stack1 and stack2. Restoring stack1 and stack2 involves popping 
a character in tmp_stack, and pushing it to both stack1 and stack2. And this
is done repeatedly until tmp stack is empty.

You can include "stack.h" and use the stack ADT operations. The arraystack.c
will automatically be linked by the make. You can assume the size of
the given stack is 100.

You can test using 'make test_compare'.


